import * as lexer from './lexer';
import { Block, Extends, FromImport, Import, Include, Macro, Node, NodeList, Output, Root, Set, Switch, Symbol } from './nodes';
import { Token, ParserExtension } from './types';
export declare class Parser {
    tokenizer: lexer.Tokenizer;
    peeked: Token | null;
    breakOnBlocks: string[] | null;
    dropLeadingWhitespace: boolean;
    extensions: ParserExtension<Parser>[];
    constructor(tokens: lexer.Tokenizer);
    init(tokens: lexer.Tokenizer): void;
    nextToken(withWhitespace?: boolean): Token | null;
    peekToken(): Token;
    pushToken(tok: Token): void;
    error(msg: string, lineno?: number, colno?: number): import("./lib").TemplateErr;
    fail(msg: string, lineno?: number, colno?: number): void;
    skip(type: string): boolean;
    expect(type: string): Token;
    skipValue(type: string, val: any): boolean;
    skipSymbol(val: any): boolean;
    advanceAfterBlockEnd(name?: string): any;
    advanceAfterVariableEnd(): void;
    parseFor(): any;
    parseMacro(): Macro;
    parseCall(): Output;
    parseWithContext(): any;
    parseImport(): Import;
    parseFrom(): FromImport;
    parseBlock(): Block;
    parseExtends(): Extends;
    parseInclude(): Include;
    parseIf(): any;
    parseSet(): Set;
    parseSwitch(): Switch;
    parseStatement(): any;
    parseRaw(tagName?: 'raw' | 'verbatim'): Output;
    parsePostfix(node: any): any;
    parseInlineIf(): any;
    parseOr(): any;
    parseAnd(): any;
    parseNot(): any;
    parseIn(): any;
    parseIs(): any;
    parseCompare(): any;
    parseConcat(): any;
    parseAdd(): any;
    parseSub(): any;
    parseMul(): any;
    parseDiv(): any;
    parseFloorDiv(): any;
    parseMod(): any;
    parsePow(): any;
    parseUnary(noFilters?: boolean): any;
    parsePrimary(noPostfix?: boolean): any;
    parseFilterName(): Symbol;
    parseFilterArgs(node: Node): any;
    parseFilter(node: Node): Node;
    parseFilterStatement(): Output;
    parseAggregate(): any;
    parseSignature(tolerant?: any, noParens?: boolean): NodeList;
    parseUntilBlocks(...blockNames: any[]): NodeList;
    parseNodes(): any[];
    parse(): NodeList;
    parseAsRoot(): Root;
}
export declare const parse: (src: any, extensions: any, opts: any) => Root;
