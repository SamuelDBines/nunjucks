import { Node } from './nodes';
import { Frame } from './runtime';
import { Obj } from './loader';
interface ICompilerOpts {
    codebuf?: any[];
    lastId?: number;
    buffer?: any;
    bufferStack?: Buffer[];
    _scopeClosers?: string;
    inBlock?: boolean;
    throwOnUndefined?: boolean;
}
declare class Compiler extends Obj {
    templateName: string;
    lastId: number;
    _scopeClosers: string;
    inBlock: boolean;
    throwOnUndefined: boolean;
    codebuf: any[];
    buffer: any;
    bufferStack: any[];
    init(templateName: string, opts?: ICompilerOpts): void;
    fail(msg: string, lineno?: number, colno?: number): void;
    _pushBuffer(): string;
    _popBuffer(): void;
    _emit(code: any): void;
    _emitLine(code: string): void;
    _emitLines(...lines: any[]): void;
    _emitFuncBegin(node: any, name: any): void;
    _emitFuncEnd(noReturn?: boolean): void;
    _addScopeLevel(): void;
    _closeScopeLevels(): void;
    _withScopedSyntax(func: Function): void;
    _makeCallback(res?: any): string;
    _tmpid(): string;
    _templateName(): string;
    _compileChildren(node: any, frame: any): void;
    _compileAggregate(node: Node, frame: Frame, startChar?: string, endChar?: string): void;
    _compileExpression(node: any, frame: any): void;
    assertType(node: Node, ...types: any[]): void;
    compileCallExtension(node: Node | any, frame: Frame, async: any): void;
    compileCallExtensionAsync(node: any, frame: any): void;
    compileNodeList(node: Node, frame: Frame): void;
    compileLiteral(node: Node): void;
    compileSymbol(node: Node, frame: Frame): void;
    compileGroup(node: Node, frame: Frame): void;
    compileArray(node: Node, frame: Frame): void;
    compileDict(node: Node, frame: Frame): void;
    compilePair(node: Node, frame: Frame): void;
    compileInlineIf(node: Node, frame: Frame): void;
    compileIn(node: any, frame: any): void;
    compileIs(node: any, frame: any): void;
    _binOpEmitter(node: any, frame: any, str: any): void;
    compileOr(node: Node, frame: Frame): void;
    compileAnd(node: Node, frame: Frame): void;
    compileAdd(node: Node, frame: Frame): void;
    compileConcat(node: Node, frame: Frame): void;
    compileSub(node: Node, frame: Frame): void;
    compileMul(node: Node, frame: Frame): void;
    compileDiv(node: Node, frame: Frame): void;
    compileMod(node: Node, frame: Frame): void;
    compileNot(node: Node, frame: Frame): void;
    compileFloorDiv(node: any, frame: any): void;
    compilePow(node: any, frame: any): void;
    compileNeg(node: any, frame: any): void;
    compilePos(node: any, frame: any): void;
    compileCompare(node: any, frame: any): void;
    compileLookupVal(node: any, frame: any): void;
    _getNodeName(node: any): any;
    compileFunCall(node: any, frame: any): void;
    compileFilter(node: any, frame: any): void;
    compileFilterAsync(node: any, frame: any): void;
    compileKeywordArgs(node: Node, frame: Frame): void;
    compileSet(node: any, frame: Frame): void;
    compileSwitch(node: any, frame: Frame): void;
    compileIf(node: any, frame: any, async: any): void;
    compileIfAsync(node: Node, frame: Frame): void;
    _emitLoopBindings(node: Node, arr: any[] | any, i: number | any, len: number | any): void;
    compileFor(node: Node, frame: any): void;
    _compileAsyncLoop(node: any, frame: any, parallel?: boolean): void;
    compileAsyncEach(node: Node, frame: Frame): void;
    compileAsyncAll(node: Node, frame: Frame): void;
    _compileMacro(node: Node, frame?: Frame): string;
    compileMacro(node: any, frame: any): void;
    compileCaller(node: Node, frame: Frame): void;
    _compileGetTemplate(node: any, frame: Frame, eagerCompile: any, ignoreMissing: boolean): string;
    compileImport(node: any, frame: any): void;
    compileFromImport(node: any, frame: any): void;
    compileBlock(node: Node): void;
    compileSuper(node: any, frame: any): void;
    compileExtends(node: any, frame: any): void;
    compileInclude(node: any, frame: any): void;
    compileTemplateData(node: any, frame: any): void;
    compileCapture(node: any, frame: any): void;
    compileOutput(node: any, frame: any): void;
    compileRoot(node: any, frame: any): void;
    compile(node: any, frame?: any): void;
    getCode(): string;
}
export declare const compile: (src: string, //TODO: check this is true
asyncFilters: readonly string[], extensions: any[], name: string, opts?: ICompilerOpts) => string;
declare const _default: {
    compile: (src: string, asyncFilters: readonly string[], extensions: any[], name: string, opts?: ICompilerOpts) => string;
    Compiler: typeof Compiler;
};
export default _default;
